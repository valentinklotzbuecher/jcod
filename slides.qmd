---
title: "Synthetic Control Methods"
subtitle: "Department of Clinical Research - Journal Club / Open Discussion"
author: "Valentin Klotzbücher"
date: last-modified

# one source → two decks
format:
  revealjs:
    theme: [default, theme-dark.scss]
    slide-number: true
    incremental: false
    toc: false
    center: false
    width: 1280
    height: 720
    format-links: [beamer]
  beamer:
    aspectratio: 169
    include-in-header: beamer-unibas.tex
    fonttheme: professionalfonts
    classoption:
      - "t"  # Top-align content

bibliography: references.bib
csl: the-quarterly-journal-of-economics.csl

execute:
  echo: false
  warning: false
  message: false
---

## Motivation

---

## When you only treat one unit

Examples where SCM-style thinking is natural:

- Synthetic Jena (mask mandate) [@MitzeEtAl2020FaceMasksSCM]
- Synthetic Basque country (terror against tourists) [@AbadieGardeazabal2003BasqueConflict]
- Synthetic Karl Marx (citations) [@MagnessMakovi2023MainstreamingMarx]

Single treated unit + panel outcome → need a counterfactual path \(Y_{1t}(0)\).

---

## SCM in the wild

::: columns
::: {.column width="50%"}
![](images/Screenshot%202026-01-19%20at%2016.40.36.png){width=100%}
:::
::: {.column width="50%"}
![](images/Screenshot%202026-01-19%20at%2016.40.11.png){width=100%}
:::
:::

---

## Terminology

| Context | Meaning |
|---|---|
| Clinical “synthetic control arm” | patient-level external controls, PS/transportability |
| Econometric SCM | unit-level panel, weighted donor trajectory over time |

Today is the second meaning.

---

## Why SCM here (and why DiD struggles)

- Goal: recover the untreated path for the treated unit, \(Y_{1t}(0)\)
- DiD needs parallel trends; with one treated unit this is untestable and often implausible
- Common shocks can hit units differently and break DiD
- SCM builds a comparison unit by weighting donors to match pre-period outcomes

```{r}
#| label: prep
#| include: false
#| cache: true

# ── Libraries ──
library(dplyr)
library(tidyr)
library(ggplot2)
library(scpi)
library(lubridate)
set.seed(420)

# ── Simulation: Monthly data ──
hospitals <- c("Basel", "Zurich", "Bern", "Geneva", "Lausanne",
               "St_Gallen", "Luzern", "Aarau", "Winterthur",
               "Fribourg", "Chur", "Bellinzona")

# Monthly sequence: Jan 2012 to Dec 2023
months <- seq(as.Date("2012-01-01"), as.Date("2023-12-01"), by = "month")
T0_date <- as.Date("2018-07-01")  # Treatment starts July 2018
treated_unit <- "Basel"

# Numeric time index for models (months since start)
time_idx <- seq_along(months)
T0 <- which(months == T0_date)
pre_periods <- 1:(T0 - 1)

# Time trend with latent factors + seasonality
time_trend <- tibble(
  month = months,
  t = time_idx,
  # Linear trend (gradual decline)
  lambda = -0.015 * (t - 1),
  # Latent factor 1: smooth business cycle (~4 year period)
  f1 = 1.2 * sin(2 * pi * t / 48),
  # Latent factor 2: policy shock around 2020 (COVID-like)
  f2 = -1.5 * plogis((t - 97) / 3) + 0.8 * plogis((t - 109) / 4),
  # Seasonality (winter peaks for hospital data)
  season = 0.6 * cos(2 * pi * (month(month) - 1) / 12)
)

# Hospital parameters (heterogeneous factor loadings)
hosp_par <- tibble(
  hospital = hospitals,
  alpha_i  = rnorm(length(hospitals), 0, 1.2),
  gamma1_i = rnorm(length(hospitals), 1.0, 0.3),   # loading on f1
  gamma2_i = rnorm(length(hospitals), 1.0, 0.25),  # loading on f2
  season_i = rnorm(length(hospitals), 1.0, 0.2)    # seasonal sensitivity
) %>%
  # Basel has different loadings (violates parallel trends)
  mutate(
    gamma1_i = dplyr::if_else(hospital == treated_unit, gamma1_i + 0.4, gamma1_i),
    gamma2_i = dplyr::if_else(hospital == treated_unit, gamma2_i - 0.3, gamma2_i)
  )

# Panel data
df <- expand_grid(hospital = hospitals, t = time_idx) %>%
  left_join(time_trend, by = "t") %>%
  left_join(hosp_par, by = "hospital") %>%
  mutate(
    treated = (hospital == treated_unit),
    post    = (t >= T0),
    # Potential outcome without treatment
    mu0 = 50 + alpha_i + lambda + gamma1_i * f1 + gamma2_i * f2 + season_i * season,
    # Treatment effect: gradual phase-in over 6 months, then stable at -2.5
    months_post = pmax(0, t - T0 + 1),
    tau = dplyr::if_else(treated & post, -2.5 * pmin(months_post / 6, 1), 0),
    # Observed outcome
    y = mu0 + tau + rnorm(n(), 0, 0.8)
  ) %>%
  select(hospital, month, t, treated, post, y)

# ── scpi SCM (canonical simplex weights) ──
period_pre  <- 1:(T0 - 1)
period_post <- T0:max(df$t)

dat_sc <- scdata(
  df = df,
  id.var = "hospital",
  time.var = "t",
  outcome.var = "y",
  features = "y",
  unit.tr = treated_unit,
  unit.co = setdiff(hospitals, treated_unit),
  period.pre = period_pre,
  period.post = period_post,
  constant = TRUE
)

res_scpi <- scpi(
  data = dat_sc,
  w.constr = list(name = "simplex"),
  sims = 200,
  e.method = "gaussian"
)

p_pi <- scplot(
  result = res_scpi,
  plot.range = c(min(df$t), max(df$t)),
  label.xy = list(x.lab = NULL, y.lab = "Outcome"),
  x.ticks = seq(min(df$t), max(df$t), by = 24),
  e.out = TRUE,
  joint = FALSE
)

donors <- setdiff(hospitals, treated_unit)

# --- Extract series for plotting from scpi ---
Y_pre_actual <- res_scpi$data$Y.pre
Y_post_actual <- res_scpi$data$Y.post
Y_pre_fit <- res_scpi$est.results$Y.pre.fit
Y_post_fit <- res_scpi$est.results$Y.post.fit

df_trend <- tibble(
  t = c(period_pre, period_post),
  y_tr = c(as.numeric(Y_pre_actual), as.numeric(Y_post_actual)),
  y_syn = c(as.numeric(Y_pre_fit), as.numeric(Y_post_fit))
) %>%
  left_join(time_trend %>% select(t, month), by = "t") %>%
  mutate(gap = y_tr - y_syn)

# Pre-treatment fit diagnostic
rmspe_pre <- df_trend %>%
  filter(t < T0) %>%
  summarise(rmspe = sqrt(mean(gap^2))) %>%
  pull(rmspe)

# weights for donor table
w <- NULL
if (!is.null(res_scpi$w)) w <- res_scpi$w
if (is.null(w) && !is.null(res_scpi$w.est)) w <- res_scpi$w.est
if (is.null(w) && !is.null(res_scpi$est.results$w)) w <- res_scpi$est.results$w
stopifnot(!is.null(w))

if (!is.null(names(w))) {
  names(w) <- sub("^.*\\.", "", names(w))
}
w <- w[donors]

p_scpi_trends <- ggplot(df_trend, aes(month)) +
  geom_line(aes(y = y_tr), linewidth = 0.8) +
  geom_line(aes(y = y_syn), linetype = 2, linewidth = 0.8) +
  geom_vline(xintercept = T0_date, linetype = 2) +
  labs(title = "SCM (scpi): Basel vs synthetic", x = NULL, y = "Outcome") +
  theme_minimal()

p_scpi_gap <- ggplot(df_trend, aes(month, gap)) +
  geom_hline(yintercept = 0) +
  geom_line(linewidth = 0.8) +
  geom_vline(xintercept = T0_date, linetype = 2) +
  labs(title = "SCM gap (Basel − synthetic)", x = NULL, y = "Gap") +
  theme_minimal()

# ── Blank-period validation (holdout pre-period) ──
TE <- T0 - 12  # last 12 months pre-treatment as blank period
period_fit <- 1:TE
period_blank <- (TE + 1):(T0 - 1)

dat_fit <- scdata(
  df = df,
  id.var = "hospital",
  time.var = "t",
  outcome.var = "y",
  features = "y",
  unit.tr = treated_unit,
  unit.co = setdiff(hospitals, treated_unit),
  period.pre = period_fit,
  period.post = period_blank,
  constant = TRUE
)

res_fit <- scpi(
  data = dat_fit,
  w.constr = list(name = "simplex"),
  sims = 200,
  e.method = "gaussian"
)

blank_df <- tibble(
  t = period_blank,
  y_tr = as.numeric(res_fit$data$Y.post),
  y_syn_blank = as.numeric(res_fit$est.results$Y.post.fit)
) %>%
  left_join(time_trend %>% select(t, month), by = "t") %>%
  mutate(gap_blank = y_tr - y_syn_blank)

p_blank_gap <- ggplot(blank_df, aes(month, gap_blank)) +
  geom_hline(yintercept = 0) +
  geom_line(linewidth = 0.8) +
  labs(title = "Blank-period validation gap (should be ~0)", x = NULL, y = "Gap") +
  theme_minimal()

att_scpi <- df_trend %>%
  filter(t >= T0) %>%
  summarise(att = mean(gap)) %>%
  pull(att)

# weights table (top 5 + other)
weights_tbl <- tibble(donor = names(w), weight = as.numeric(w)) %>%
  arrange(desc(weight)) %>%
  mutate(donor = as.character(donor))

weights_tbl_top <- weights_tbl %>%
  slice_head(n = 5)
other <- tibble(donor = "Other", weight = sum(weights_tbl$weight) - sum(weights_tbl_top$weight))
weights_tbl_show <- bind_rows(weights_tbl_top, other)

p_weights <- weights_tbl %>%
  filter(weight > 0.01) %>%
  ggplot(aes(x = reorder(donor, weight), y = weight)) +
  geom_col() +
  coord_flip() +
  labs(title = "Donor weights (shown if > 1%)", x = NULL, y = "Weight") +
  theme_minimal()

p_scm_trends <- p_scpi_trends

# ── Pre-built plots ──
# Raw panel (use dates for x-axis)
p_raw <- ggplot(df, aes(month, y, group = hospital,
                        colour = dplyr::if_else(treated, "Basel", "Donors"))) +
  geom_line(linewidth = 0.5, alpha = 0.8) +
  geom_vline(xintercept = T0_date, linetype = 2, colour = "red") +
  scale_colour_manual(values = c("Basel" = "steelblue", "Donors" = "grey60")) +
  scale_x_date(date_breaks = "2 years", date_labels = "%Y") +
  labs(title = "Simulated monthly panel: Basel (treated) vs donors",
       subtitle = paste0("Vertical line: treatment (", format(T0_date, "%b %Y"), ")"),
       x = NULL, y = "Outcome", colour = NULL) +
  theme_minimal()

# Format treatment date for slides
T0_label <- format(T0_date, "%B %Y")
```

<!-- ═══════════════════════════════════════════════════════════════════════ -->
<!-- SECTION A — Motivation & Literature                                     -->
<!-- ═══════════════════════════════════════════════════════════════════════ -->

<!-- ═══════════════════════════════════════════════════════════════════════ -->
<!-- SECTION B — SCM Core                                                    -->
<!-- ═══════════════════════════════════════════════════════════════════════ -->

## What SCM is

---

## SCM intuition

**Core idea:** Build a *synthetic control* as a weighted combination of donor units.

- Weights chosen to match the treated unit's pre-treatment trajectory
- The synthetic unit serves as the counterfactual
- Treatment effect = observed outcome − synthetic outcome

$$
\widehat{Y}_{1t}^{(0)} = r + \sum_{j=2}^{J+1} w_j \cdot Y_{jt} \quad \text{where } \sum_j w_j = 1, \; w_j \geq 0
$$

Level adjustment $r$ (intercept) is allowed here.

::: notes
We're constructing a "frankenunit" from donors that looks like the treated unit pre-treatment.
:::

---

## SCM objective + weights

Weights minimize pre-treatment prediction error:

$$
\min_{W, r} \sum_{t < T_0} \left( Y_{1t} - r - \sum_{j=2}^{J+1} w_j Y_{jt} \right)^2
$$

Subject to:

- $w_j \geq 0$ (no negative weights)
- $\sum_j w_j = 1$ (convex combination)

**Result:** Sparse weights; typically few donors receive positive weight.

::: notes
The optimization is a constrained regression. Sparsity helps interpretability—we can say "synthetic Basel is 60% Zurich + 40% Bern."
:::

---

## Trust & diagnostics

---

## Diagnostics workflow

Before trusting SCM estimates:

1. **Pre-fit balance:** Does synthetic match treated pre-treatment?
2. **Weights inspection:** Are weights sensible? Too concentrated?
3. **Placebo tests:** Run SCM on each donor as if treated
4. **Pre-treatment RMSPE:** Large gaps pre-treatment → unreliable post-treatment

::: notes
Diagnostics are essential. A poor pre-fit means the counterfactual is unreliable.
:::

---

## Pre-treatment fit (RMSPE)

```{r}
#| label: show-rmspe
cat("Pre-treatment RMSPE:", round(rmspe_pre, 3))
```

If pre-fit is bad, stop.

---

## Preregisterable discipline: train → validate → lock → test

A practical workflow (trial culture):

- **Train** weights on early pre-period
- **Validate** on a late pre-period “blank” window (still untreated)
- **Lock** weights (no more tuning)
- **Test** only then look at post-\(T_0\)

This is design discipline, not magic.

---

## Blank-period validation (pre-treatment holdout)

```{r}
#| label: show-blank-gap
p_blank_gap
```

---

## SCM as experimental design

@AbadieZhao2025SCD perspective:

- **Design with SCM in mind** — choose treated unit where good donors exist
- **Pre-register the donor pool** — reduces researcher degrees of freedom
- **Balance as design criterion** — not just an estimation property

**Key insight:** SCM works best when the study is designed for it, not retrofitted.

::: notes
This is a shift in thinking: from "how do I analyze this data?" to "how do I design this study so SCM will work?"
:::

---

<!-- ═══════════════════════════════════════════════════════════════════════ -->
<!-- SECTION D — Simulation Illustration                                     -->
<!-- ═══════════════════════════════════════════════════════════════════════ -->

## Example

---

## Simulation design

**Monthly panel with latent factors:**

- 12 Swiss hospitals, Jan 2012 – Dec 2023 (144 months)
- Basel treated at $T_0$ = July 2018
- True ATT = −2.5 (gradual phase-in over 6 months)
- Two latent factors + seasonality; Basel has different loadings

This setup *violates* parallel trends—donors respond differently to common shocks.

::: notes
We deliberately create a scenario where DiD would struggle but SCM methods should recover the effect.
:::

---

## Raw panel

```{r}
#| label: show-raw-panel
p_raw
```

::: notes
Notice the heterogeneous trends—this is why parallel trends won't hold.
:::

---

## SCM: Basel vs Synthetic Control

```{r}
#| label: show-scm-trends
p_scpi_trends
```

```{r}
#| label: show-scm-att
cat("SCM (scpi) ATT:", round(att_scpi, 3))
```

::: notes
The synthetic control tracks Basel well pre-treatment, then diverges post-July 2018.
:::

---

## Uncertainty (scpi prediction intervals)

```{r}
#| label: show-scpi-pi
p_pi$plot_out
```

---

## Gap over time

gap_t = treated - synthetic; vertical line = treatment start.

```{r}
#| label: show-scm-gap
p_scpi_gap
```

---

## Donor weights

```{r}
#| label: show-weights
knitr::kable(weights_tbl_show, digits = 3)
```

```{r}
#| label: show-weights-plot
p_weights
```

---

## Practical guidance

---

## Practical checklist + limitations

**Before using SCM:**

- ☑ Sufficient pre-treatment periods (≥ 5–10)
- ☑ Good donor pool (similar, unaffected units)
- ☑ Treatment timing known and sharp
- ☑ No anticipation effects

**Limitations:**

- Sparse donors → poor synthetic match
- Extrapolation impossible with convex weights
- Inference remains an active research area

::: notes
These are necessary conditions. Violations lead to unreliable estimates.
:::

---

## When NOT to use this

- Not for patient-level RCT replacement (most CTU work)
- Not when you have many treated units with staggered timing (see staggered DiD/event-study literature)
- Not when intervention timing is fuzzy or anticipation is huge
- Not when measurement/reporting changes exactly at treatment

---

## Takeaways

1. **SCM constructs** a counterfactual rather than assuming parallel trends
2. **Diagnostics are essential:** pre-fit, weights, placebos
3. **Modern extensions** (IFE, MC, SDID) handle complex factor structures
4. **scpi is the canonical package** — use it for inference and prediction intervals
5. **Design matters more than estimator:** clean setting → all methods work; violated assumptions → all struggle

::: notes
The method is only as good as the setting. Focus on design.
:::

---

## Extensions menu

- SDID (unit + time weights): when I'd consider it — pre-trends vary and time reweighting helps
- AugSCM (SCM + outcome-model bias correction): when I'd consider it — convex hull is weak but modeling is plausible
- IFE/MC (factor/low-rank imputation): when I'd consider it — long panels with strong latent factors

---

## Software

- `scpi`: canonical SCM + inference/pred intervals (R; Stata/Python ports available)
- `synthdid`, `augsynth`: hybrid / DR-ish extensions
- `fect`: IFE/MC workflows

---

## Appendix: extensions

---

## Why classical SCM can fail

Limitations of the original method:

- **Overfitting:** Too many predictors relative to pre-periods
- **Interpolation bias:** Treated unit outside convex hull of donors
- **No extrapolation:** Convex weights can't capture factor loadings outside donor range
- **Single factor structure:** May miss complex latent heterogeneity

---

## Imputation family: IFE / MC

**Interactive Fixed Effects (IFE):**
$$Y_{it} = \alpha_i + \gamma_t + \sum_{k=1}^{K} \lambda_{ik} f_{kt} + \varepsilon_{it}$$

Latent factors $f_{kt}$ with unit-specific loadings $\lambda_{ik}$.

**Matrix Completion (MC):**
Low-rank imputation — treat missing $Y_{1t}^{(0)}$ as matrix completion problem.

**Package:** `fect` (successor to `gsynth`) — not run here, but excellent for factor-augmented estimation.

---

## Hybrid family: SDID / AugSCM

**Synthetic Difference-in-Differences (SDID):**

- SCM-style unit weights + DiD-style time weights
- Reweights both donors and pre-periods
- Package: `synthdid`

**Augmented SCM:**

- SCM + ridge regression bias correction
- Reduces interpolation bias
- Package: `augsynth`

---

## References
